rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for cleaner, more efficient rules
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    function getUserGroupId() {
      let userData = getUserData();
      return userData != null && 'groupId' in userData ? userData.groupId : null;
    }
    
    function isInSameGroup(userId) {
      let userGroupId = getUserGroupId();
      let otherUser = get(/databases/$(database)/documents/users/$(userId));
      return userGroupId != null && 
             otherUser != null && 
             otherUser.data != null &&
             'groupId' in otherUser.data &&
             userGroupId == otherUser.data.groupId;
    }
    
    // Users - can read/write own doc, read group members
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
      allow read: if isAuthenticated() && userId != request.auth.uid && isInSameGroup(userId);
    }
    
    // User Groups - members can read, anyone can create (for onboarding)
    match /userGroups/{groupId} {
      allow read: if isAuthenticated() && 
        (request.auth.uid in resource.data.memberIds || 
         (getUserGroupId() != null && getUserGroupId() == groupId));
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && 
        (request.auth.uid in resource.data.memberIds ||
         // Allow adding self when accepting invitation
         (request.auth.uid in request.resource.data.memberIds &&
          request.resource.data.memberIds.hasAll(resource.data.memberIds)));
      allow delete: if isAuthenticated() && 
        resource.data.memberIds.size() == 0; // Can only delete empty groups
    }
    
    // Entries - users can access own and group members' entries
    match /entries/{entryId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.date >= timestamp.date(2025, 1, 1);
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        // Prevent moving entries before service start
        (request.resource.data.date == null || request.resource.data.date >= timestamp.date(2025, 1, 1));
      allow delete: if isAuthenticated() && 
        (resource == null || resource.data.userId == request.auth.uid);
    }
    
    // Group invitations - simplified access
    match /groupInvitations/{invitationId} {
      allow list: if isAuthenticated();
      allow get: if isAuthenticated() && 
        (request.auth.token.email == resource.data.invitedEmail ||
         request.auth.uid == resource.data.invitedBy);
      allow create: if isAuthenticated() &&
        request.resource.data.invitedBy == request.auth.uid &&
        (getUserGroupId() == request.resource.data.groupId ||
         request.auth.uid in get(/databases/$(database)/documents/userGroups/$(request.resource.data.groupId)).data.memberIds);
      allow update: if isAuthenticated() &&
        request.auth.token.email == resource.data.invitedEmail;
      allow delete: if isAuthenticated() &&
        (request.auth.uid == resource.data.invitedBy || // Sender can cancel
         request.auth.token.email == resource.data.invitedEmail); // Recipient can delete when accepting/rejecting
    }
    
    // Exchange rates - all authenticated users can read/write
    match /exchangeRates/{document=**} {
      allow read, write: if isAuthenticated();
    }
    
    // Recurring templates - users can only access their own
    match /recurringTemplates/{templateId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.createdBy == request.auth.uid &&
        // Enforce start and end dates not before service start
        request.resource.data.startDate >= timestamp.date(2025, 1, 1) &&
        request.resource.data.recurrence.endDate >= timestamp.date(2025, 1, 1) &&
        // endDate must not be before start
        request.resource.data.recurrence.endDate >= request.resource.data.startDate;
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        // If startDate/endDate are updated, enforce bounds
        (request.resource.data.startDate == null || request.resource.data.startDate >= timestamp.date(2025, 1, 1)) &&
        (request.resource.data.recurrence.endDate == null || request.resource.data.recurrence.endDate >= timestamp.date(2025, 1, 1)) &&
        (request.resource.data.recurrence.endDate == null || request.resource.data.startDate == null || request.resource.data.recurrence.endDate >= request.resource.data.startDate);
      allow delete: if isAuthenticated() && 
        (resource == null || resource.data.userId == request.auth.uid);
    }
  }
}